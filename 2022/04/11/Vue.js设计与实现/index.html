<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        
    
    <link rel='stylesheet' href="/./css/dracula.css">

        <title>《Vue.js设计与实现》笔记</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=2.0">
<link rel="stylesheet" href="/css/style.css">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="manifest" href="/site.webmanifest">

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <header class="al_header al_pos_fixed">
    <div class="al_header_container dis_flex_jcenter">
        <div class="al_header_container_left">
            <div class="al_header_site_title">
                <a href="/">Joker Won's Stack</a>
            </div>
        </div>

        <div class="dis_flex_jcenter">
            <div class="al_header_setting">
                <svg class="al_header_icon">
                    <use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-menu"></use>
                </svg>
            </div>
        </div>
    </div>
</header>

        <div class="al_sidebar">

    <div class="al_sidebar_overlay al_full_cover"></div>

    <div class="al_pos_fixed al_sidebar_cnt">
        <div class="dis_flex_acenter al_sidebar_header">
            <h3>Joker Won's Stack</h3>
            <div class="al_sidebar_close al_header_setting">
                <svg class="al_header_icon">
                    <use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-close"></use>
                </svg>
            </div>
        </div>

        <div class="al_sidebar_author_cnt">

            <div class="al_sidebar_author_info">
                <h4>Joker Won</h4>
                <img class="al_sidebar_avatar" src="https://cdn.jsdelivr.net/gh/jokerwon/images/img/avatar.jpg">
                <p>热衷于各种前端技术，目前偏爱钻研前端工程化。希望能找个大佬带带我 >_<。</p>
            </div>

            
        </div>
    </div>
</div>

        
    <div class="dis_flex_center al_lightbox_cnt al_full_cover">
        <img class="al_lightbox_img"/>
    </div>
    <div class="al_page_background dis_flex_center al_full_cover"></div>
    <div class="al_page_container">
        <div class="al_pos_ab al_fake_background"></div>
        <div class="al_main_container al_shadow al_main_page_container">
            <article class="al_article">
                <header>
                    <h1 class="al_page_title">
                        《Vue.js设计与实现》笔记
                    </h1>
                    <div class="al_page_info dis_flex">
                        <div class="al_page_content_info">
                            Mon April 11, 2022 11:20 PM
                        </div>

                        

                        
                        <span class="tags"></span>
                    </div>
                </header>

                
                    <div class="al_page_content_outline">
                        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9D%83%E8%A1%A1%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-text">第一章 权衡的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E5%91%BD%E4%BB%A4%E5%BC%8F%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-text">1.1 命令式和声明式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-text">1.2 性能与可维护性的权衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">1.3 虚拟DOM的性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%92%8C%E7%BC%96%E8%AF%91%E6%97%B6"><span class="toc-text">1.4 运行时和编译时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0"><span class="toc-text">第二章 框架设计的核心要素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E6%8F%90%E5%8D%87%E7%94%A8%E6%88%B7%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C"><span class="toc-text">2.1 提升用户的开发体验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%93%E7%A7%AF"><span class="toc-text">2.2 控制框架代码的体积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E6%A1%86%E6%9E%B6%E8%A6%81%E5%81%9A%E5%88%B0%E8%89%AF%E5%A5%BD%E7%9A%84-Tree-Shaking"><span class="toc-text">2.3 框架要做到良好的 Tree-Shaking</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Tree-Shaking%EF%BC%9F"><span class="toc-text">什么是 Tree-Shaking？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Tree-Shaking%EF%BC%9F"><span class="toc-text">如何实现 Tree-Shaking？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-%E6%A1%86%E6%9E%B6%E5%BA%94%E8%AF%A5%E8%BE%93%E5%87%BA%E6%80%8E%E6%A0%B7%E7%9A%84%E6%9E%84%E5%BB%BA%E4%BA%A7%E7%89%A9"><span class="toc-text">2.4 框架应该输出怎样的构建产物</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-%E7%89%B9%E6%80%A7%E5%BC%80%E5%85%B3"><span class="toc-text">2.5 特性开关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">2.6 错误处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7-%E8%89%AF%E5%A5%BD%E7%9A%84-TypeScript-%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81"><span class="toc-text">2.7 良好的 TypeScript 类型支持</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Vue-js-3-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-text">第三章 Vue.js 3 的设计思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%9C%B0%E6%8F%8F%E8%BF%B0-UI"><span class="toc-text">3.1 声明式地描述 UI</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%92%8C-JavaScript-%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0-UI-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">使用模板和 JavaScript 对象描述 UI 有何不同？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E5%88%9D%E8%AF%86%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-text">3.2 初识渲染器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">第四章 响应系统的作用与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%89%AF%E4%BD%9C%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">4.1 响应式数据与副作用函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 响应式数据的基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.3 设计一个完善的响应式系统</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2%E4%B8%8E-cleanup"><span class="toc-text">4.4 分支切换与 cleanup</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2"><span class="toc-text">分支切换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98"><span class="toc-text">分析问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-%E5%B5%8C%E5%A5%97%E7%9A%84-effect-%E4%B8%8E-effect-%E6%A0%88"><span class="toc-text">4.5 嵌套的 effect 与 effect 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E9%9C%80%E6%B1%82"><span class="toc-text">新需求</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-%E9%81%BF%E5%85%8D%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E5%BE%AA%E7%8E%AF"><span class="toc-text">4.6 避免无限递归循环</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-1"><span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98-1"><span class="toc-text">分析问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-%E8%B0%83%E5%BA%A6%E6%89%A7%E8%A1%8C"><span class="toc-text">4.7 调度执行</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E9%9C%80%E6%B1%82-1"><span class="toc-text">新需求</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-1"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4"><span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%95%E7%94%B3-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%B0%83%E5%BA%A6%E5%99%A8%E5%90%88%E5%B9%B6%E5%A4%9A%E6%AC%A1%E9%87%8D%E5%A4%8D%E6%9B%B4%E6%96%B0"><span class="toc-text">引申: 实现简易调度器合并多次重复更新</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-8-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-computed-%E4%B8%8E-lazy"><span class="toc-text">4.8 计算属性 computed 与 lazy</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E9%9C%80%E6%B1%82-2"><span class="toc-text">新需求</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-2"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-5"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-9-watch-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4.9 watch 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E9%9C%80%E6%B1%82-3"><span class="toc-text">新需求</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-6"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-10-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E7%9A%84-watch-%E4%B8%8E%E5%9B%9E%E8%B0%83%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-text">4.10 立即执行的 watch 与回调执行时机</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E9%9C%80%E6%B1%82-4"><span class="toc-text">新需求</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-7"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-11-%E8%BF%87%E6%9C%9F%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-text">4.11 过期的副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B0%E9%9C%80%E6%B1%82-5"><span class="toc-text">新需求</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-8"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-12-%E6%80%BB%E7%BB%93"><span class="toc-text">4.12 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-WeakMap-%E5%AD%98%E5%82%A8%E5%89%AF%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">1. 为什么使用 WeakMap 存储副作用？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-trigger-%E4%B8%AD%E4%BE%9D%E8%B5%96%E9%9B%86%E5%90%88%E8%A6%81%E5%A4%8D%E5%88%B6%E5%90%8E%E5%86%8D%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-text">2. 为什么 trigger 中依赖集合要复制后再进行遍历？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%9D%9E%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%96%B9%E6%A1%88"><span class="toc-text">第五章 非原始值的响应式方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E7%90%86%E8%A7%A3-Proxy-%E5%92%8C-Reflect"><span class="toc-text">5.1 理解 Proxy 和 Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-2"><span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98-2"><span class="toc-text">分析问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-9"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-JavaScript-%E5%AF%B9%E8%B1%A1%E5%8F%8A-Proxy-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">5.2 JavaScript 对象及 Proxy 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%AF%B9%E8%B1%A1-ordinary-object"><span class="toc-text">常规对象(ordinary object)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E8%B4%A8%E5%AF%B9%E8%B1%A1-exotic-object"><span class="toc-text">异质对象(exotic object)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95-internal-method"><span class="toc-text">内部方法(internal method)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">如何区分一个对象是普通对象还是函数？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-%E5%A6%82%E4%BD%95%E4%BB%A3%E7%90%86-Object"><span class="toc-text">5.3 如何代理 Object</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-%E5%90%88%E7%90%86%E5%9C%B0%E8%A7%A6%E5%8F%91%E5%93%8D%E5%BA%94"><span class="toc-text">5.4 合理地触发响应</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-3"><span class="toc-text">存在的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98-3"><span class="toc-text">分析问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-10"><span class="toc-text">解决方案</span></a></li></ol></li></ol></li></ol></li></ol>
                    </div>
                

                
                <section id="post-body">
                    <h3 id="第一章-权衡的艺术"><a href="#第一章-权衡的艺术" class="headerlink" title="第一章 权衡的艺术"></a>第一章 权衡的艺术</h3><span id="more"></span>



<h5 id="1-1-命令式和声明式"><a href="#1-1-命令式和声明式" class="headerlink" title="1.1 命令式和声明式"></a>1.1 命令式和声明式</h5><h5 id="1-2-性能与可维护性的权衡"><a href="#1-2-性能与可维护性的权衡" class="headerlink" title="1.2 性能与可维护性的权衡"></a>1.2 性能与可维护性的权衡</h5><p>声明式代码的性能不优于命令式性能的代码。</p>
<p>声明式代码的更新性能消耗 &#x3D; 找出差异的性能消耗 + 直接修改的性能消耗。</p>
<p>很难写出绝对优化的命令式代码。</p>
<h5 id="1-3-虚拟DOM的性能"><a href="#1-3-虚拟DOM的性能" class="headerlink" title="1.3 虚拟DOM的性能"></a>1.3 虚拟DOM的性能</h5><p>性能差 –&gt; 性能高</p>
<table>
<thead>
<tr>
<th></th>
<th>innerHTML(模板)</th>
<th>虚拟DOM</th>
<th>原生 JavaScript</th>
</tr>
</thead>
<tbody><tr>
<td>心智负担</td>
<td>中等</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>可维护性</td>
<td></td>
<td>强</td>
<td>差</td>
</tr>
<tr>
<td>性能</td>
<td>差</td>
<td>不错</td>
<td>高</td>
</tr>
</tbody></table>
<h5 id="1-4-运行时和编译时"><a href="#1-4-运行时和编译时" class="headerlink" title="1.4 运行时和编译时"></a>1.4 运行时和编译时</h5><p>纯运行时：无法分析用户提供的内容。</p>
<p>运行时 + 编译时：编译时可以分析用户提供内容，并在运行时做进一步优化。<a target="_blank" rel="noopener" href="https://cn.vuejs.org/"><code>Vue</code></a></p>
<p>纯编译时：可以分析用户内容，性能更高，但灵活性不够好。<a target="_blank" rel="noopener" href="https://www.sveltejs.cn/"><code>Svelte</code></a></p>
<h3 id="第二章-框架设计的核心要素"><a href="#第二章-框架设计的核心要素" class="headerlink" title="第二章 框架设计的核心要素"></a>第二章 框架设计的核心要素</h3><h5 id="2-1-提升用户的开发体验"><a href="#2-1-提升用户的开发体验" class="headerlink" title="2.1 提升用户的开发体验"></a>2.1 提升用户的开发体验</h5><p>衡量一个框架是否足够优秀的指标之一就是开发体验。</p>
<h5 id="2-2-控制框架代码的体积"><a href="#2-2-控制框架代码的体积" class="headerlink" title="2.2 控制框架代码的体积"></a>2.2 控制框架代码的体积</h5><p>框架的大小也是衡量标准之一。</p>
<p>在开发环境中为用户提供友好的警告信息的同时，不会增加生产环境代码的体积。</p>
<h5 id="2-3-框架要做到良好的-Tree-Shaking"><a href="#2-3-框架要做到良好的-Tree-Shaking" class="headerlink" title="2.3 框架要做到良好的 Tree-Shaking"></a>2.3 框架要做到良好的 Tree-Shaking</h5><h6 id="什么是-Tree-Shaking？"><a href="#什么是-Tree-Shaking？" class="headerlink" title="什么是 Tree-Shaking？"></a>什么是 Tree-Shaking？</h6><p>消除永远不会被执行的代码，也就是排除 dead code。</p>
<h6 id="如何实现-Tree-Shaking？"><a href="#如何实现-Tree-Shaking？" class="headerlink" title="如何实现 Tree-Shaking？"></a>如何实现 Tree-Shaking？</h6><ul>
<li><p>模块必须是 ESM(ES Module)。因为 Tree-Shaking 依赖 ESM 的静态结构。</p>
</li>
<li><p>函数调用不会产生副作用。通常产生副作用的代码都是模块内函数的顶级调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>() <span class="comment">// 顶级调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>() <span class="comment">// 函数内调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-4-框架应该输出怎样的构建产物"><a href="#2-4-框架应该输出怎样的构建产物" class="headerlink" title="2.4 框架应该输出怎样的构建产物"></a>2.4 框架应该输出怎样的构建产物</h5><ul>
<li>直接可以在 HTML 中引用，则输出 IIFE(立即调用函数表达式)。</li>
<li>如果浏览器支持原生 ESM，可以以 <code>&lt;script type=&quot;module&quot; /&gt;</code> 的形式引用，则输出 EMS 格式资源。</li>
<li>可以在 Node 环境中运行，则输出 cjs(CommonJS)格式资。</li>
</ul>
<h5 id="2-5-特性开关"><a href="#2-5-特性开关" class="headerlink" title="2.5 特性开关"></a>2.5 特性开关</h5><p>用户可以自行开关框架提供的特性。</p>
<ul>
<li>对于用户关闭的特性，可以利用 Tree-Shaking 让其不包含在最终的资源中。</li>
<li>该机制为框架设计带来了灵活性，可以通过特性开关任意为框架添加新的特性，而不用担心资源体积变大。框架升级时，可以通过特性开关来支持遗留 API，这样新用户可以选择不使用遗留 API 来使打包的资源体积最小化。</li>
</ul>
<h5 id="2-6-错误处理"><a href="#2-6-错误处理" class="headerlink" title="2.6 错误处理"></a>2.6 错误处理</h5><p>框架错误处理机制的好坏直接决定用户应用程序的健壮性。</p>
<h5 id="2-7-良好的-TypeScript-类型支持"><a href="#2-7-良好的-TypeScript-类型支持" class="headerlink" title="2.7 良好的 TypeScript 类型支持"></a>2.7 良好的 TypeScript 类型支持</h5><p>TS 类型支持也是评价框架的重要指标。</p>
<p><strong>使用 TS 编写框架</strong> 和 <strong>对 TS 类型支持友好</strong> 是两件<strong>完全不同</strong>的事。</p>
<h3 id="第三章-Vue-js-3-的设计思路"><a href="#第三章-Vue-js-3-的设计思路" class="headerlink" title="第三章 Vue.js 3 的设计思路"></a>第三章 Vue.js 3 的设计思路</h3><p>从全局视角了解 Vue.js 3 的设计思路、工作机制及其重要组成部分。</p>
<h5 id="3-1-声明式地描述-UI"><a href="#3-1-声明式地描述-UI" class="headerlink" title="3.1 声明式地描述 UI"></a>3.1 声明式地描述 UI</h5><h6 id="使用模板和-JavaScript-对象描述-UI-有何不同？"><a href="#使用模板和-JavaScript-对象描述-UI-有何不同？" class="headerlink" title="使用模板和 JavaScript 对象描述 UI 有何不同？"></a>使用模板和 JavaScript 对象描述 UI 有何不同？</h6><p>使用 JavaScript 对象描述 UI 更加灵活。</p>
<p><code>h</code> 函数的返回值就是一个对象，其作用是让用户编写虚拟 DOM 更加轻松。所以 <code>h</code> 函数就是一个辅助创建虚拟 DOM 的工具函数。</p>
<p>Vue 会根据组件的 <code>render</code> 函数(渲染函数)的返回值拿到虚拟 DOM，然后渲染组件内容。</p>
<h5 id="3-2-初识渲染器"><a href="#3-2-初识渲染器" class="headerlink" title="3.2 初识渲染器"></a>3.2 初识渲染器</h5><p>渲染器的作用就是把虚拟 DOM 渲染为真实DOM。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jokerwon/images/img/202204032210326.png" alt="渲染器"></p>
<h3 id="第四章-响应系统的作用与实现"><a href="#第四章-响应系统的作用与实现" class="headerlink" title="第四章 响应系统的作用与实现"></a>第四章 响应系统的作用与实现</h3><h5 id="4-1-响应式数据与副作用函数"><a href="#4-1-响应式数据与副作用函数" class="headerlink" title="4.1 响应式数据与副作用函数"></a>4.1 响应式数据与副作用函数</h5><p>副作用函数指的是会产生副作用的函数。副作用函数的执行会直接或间接影响其他函数的执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">let</span> val = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  val = <span class="number">2</span> <span class="comment">// 修改全局变量，产生副作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-2-响应式数据的基本实现"><a href="#4-2-响应式数据的基本实现" class="headerlink" title="4.2 响应式数据的基本实现"></a>4.2 响应式数据的基本实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = obj.<span class="property">text</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">text</span> = <span class="string">&quot;hello vue3&quot;</span> <span class="comment">// 修改 obj.text 的值，同时希望副作用函数会重新执行</span></span><br></pre></td></tr></table></figure>

<p>实现思路：</p>
<ol>
<li>当读取字段 <code>obj.text</code> 的时候，把副作用函数 <code>effect</code> 存储起来。</li>
<li>当设置 <code>obj.text</code> 时，把副作用函数 <code>effect</code> 取出并执行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储副作用函数</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// 对原始数据的代理</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取操作</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 将副作用函数 effect 添加到 bucket 中</span></span><br><span class="line">    bucket.<span class="title function_">add</span>(effect)</span><br><span class="line">    <span class="comment">// 返回属性值</span></span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置操作</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置属性值</span></span><br><span class="line">    target[key] = newVal</span><br><span class="line">    <span class="comment">// 取出副作用函数并执行</span></span><br><span class="line">    bucket.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">    <span class="comment">// 返回 true 表示设置成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><p>后续响应式系统的章节都以该系统为基础，笔记中只会记录存在的问题、可以优化的地方、新的需求和对应的解决方案。</p>
</blockquote>
<h5 id="4-3-设计一个完善的响应式系统"><a href="#4-3-设计一个完善的响应式系统" class="headerlink" title="4.3 设计一个完善的响应式系统"></a>4.3 设计一个完善的响应式系统</h5><h6 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h6><ol>
<li><p>当前副作用函数的名字被硬编码为 <code>effect</code> 。</p>
</li>
<li><p>没有在副作用函数与被操作的目标字段之间建立明确的联系。</p>
<p>表现：修改无关字段时也会引起 <code>effect</code> 函数重新执行。</p>
</li>
</ol>
<h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><ol>
<li><p>使用一个全局变量存储被注册的副作用函数。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/e00166dd0055abcd8f27ed9380b4be4118830fe3">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个全局变量存储被注册的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect</span></span><br><span class="line">    activeEffect = fn;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册副作用函数</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = obj.<span class="property">text</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改用于存储副作用容器的数据结构。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/599e7c5fe4383a6719505f7819585c5b5248bb40">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 存储副作用函数的桶</span></span><br><span class="line"><span class="comment"> * bucket </span></span><br><span class="line"><span class="comment"> *   类型 WeakMap&lt;Target, Map&lt;string, Set&lt;Effect&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"> *   结构：</span></span><br><span class="line"><span class="comment"> *   |--&gt; target1</span></span><br><span class="line"><span class="comment"> *         |--&gt; property1</span></span><br><span class="line"><span class="comment"> *               |--&gt; effectFn1</span></span><br><span class="line"><span class="comment"> *         |--&gt; property2</span></span><br><span class="line"><span class="comment"> *               |--&gt; effectFn1</span></span><br><span class="line"><span class="comment"> *               |--&gt; effectFn2</span></span><br><span class="line"><span class="comment"> *   |--&gt; target2</span></span><br><span class="line"><span class="comment"> *         |--&gt; property3</span></span><br><span class="line"><span class="comment"> *               |--&gt; effectFn3</span></span><br><span class="line"><span class="comment"> *               |--&gt; effectFn4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">    <span class="comment">// 拦截读取操作</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeEffect) &#123;</span><br><span class="line">            <span class="keyword">return</span> target[key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 target 获取 depsMap, 它是一个 Map&lt;key, Set&lt;Effect&gt;&gt;</span></span><br><span class="line">        <span class="keyword">let</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">        <span class="comment">// 如果 depsMap 不存在，则创建一个新的 Map 与 target 关联</span></span><br><span class="line">        <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">            bucket.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再根据 key 从 depsMap 中获取 deps，它是一个 Set&lt;Effect&gt;</span></span><br><span class="line">        <span class="comment">// 里面保存着所有与当前 key 关联的副作用函数</span></span><br><span class="line">        <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="comment">// 如果 deps 不存在，同样新建一个 Set 与 key 关联</span></span><br><span class="line">        <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">            depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前激活的副作用函数添加到 deps 中</span></span><br><span class="line">        deps.<span class="title function_">add</span>(activeEffect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前 key 的值</span></span><br><span class="line">        <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截赋值操作</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置属性值</span></span><br><span class="line">        target[key] = newVal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 target 获取 depsMap，它是 key --&gt; effects</span></span><br><span class="line">        <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">        <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 key 从 depsMap 中获取对应的所有 effects</span></span><br><span class="line">        <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="comment">// 执行副作用函数</span></span><br><span class="line">        effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 true 表示赋值成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="4-4-分支切换与-cleanup"><a href="#4-4-分支切换与-cleanup" class="headerlink" title="4.4 分支切换与 cleanup"></a>4.4 分支切换与 cleanup</h5><h6 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;<span class="comment">/*...*/</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effectFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = obj.<span class="property">ok</span> ? obj.<span class="property">text</span> : <span class="string">&#x27;not&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当字段 <code>obj.ok</code> 变化时，代码执行的分支也会跟着变化，这就是所谓的分支切换。</p>
<h6 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始时 obj.ok === true</span></span><br><span class="line"><span class="comment">// data 此时的依赖树结构是</span></span><br><span class="line">data</span><br><span class="line">  |--&gt; ok</span><br><span class="line">        |--&gt; effectFn</span><br><span class="line">  |--&gt; text</span><br><span class="line">        |--&gt; effectFn</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改 obj.ok === false</span></span><br><span class="line"><span class="comment">// data 此时的依赖树结构并没有发生变化，text 对应的副作用函数会被遗留下来</span></span><br><span class="line"><span class="comment">// 但是此时理想的依赖树结构是</span></span><br><span class="line">data</span><br><span class="line">  |--&gt; ok</span><br><span class="line">        |--&gt; effectFn</span><br></pre></td></tr></table></figure>

<p>当 <code>obj.ok</code> 从 <code>true</code> 变为  <code>false</code> 后，修改 <code>obj.text</code> 依然会导致 <code>effectFn</code> 执行。</p>
<h6 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h6><p>每次副作用执行时，先把它从所有与之关联的依赖集合中删除。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/5e9ec4e6da72f96bc5ddf40e535f78063e6f5d2c">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 真实的副作用函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	      <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增</span></span><br><span class="line">        <span class="comment">// 调用 cleanup 函数完成清除工作</span></span><br><span class="line">        <span class="title function_">cleanup</span>(effectFn);</span><br><span class="line">	      <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">        activeEffect = effectFn;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增</span></span><br><span class="line">    <span class="comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合，Array&lt;Set&lt;Effect&gt;&gt;</span></span><br><span class="line">    effectFn.<span class="property">deps</span> = [];</span><br><span class="line">	  <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">    <span class="title function_">effectFn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cleanup</span>(<span class="params">effectFn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!effectFn.<span class="property">deps</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; effectFn.<span class="property">deps</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// deps 是一个包含了 effectFn 的依赖集合</span></span><br><span class="line">        <span class="keyword">const</span> deps = effectFn.<span class="property">deps</span>[i];</span><br><span class="line">        <span class="comment">// 将 effectFn 从这个依赖集合中移除</span></span><br><span class="line">        deps.<span class="title function_">delete</span>(effectFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后需要重置 effectFn.deps 数组</span></span><br><span class="line">    effectFn.<span class="property">deps</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">        bucket.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再根据 key 从 depsMap 中获取 deps，它是一个 Set&lt;Effect&gt;</span></span><br><span class="line">    <span class="comment">// 里面保存着所有与当前 key 关联的副作用函数</span></span><br><span class="line">    <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">        depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前激活的副作用函数添加到 deps 中</span></span><br><span class="line">    deps.<span class="title function_">add</span>(activeEffect);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增</span></span><br><span class="line">    <span class="comment">// deps 就是一个与当前副作用函数存在联系的依赖集合</span></span><br><span class="line">    <span class="comment">// 将其添加到 activeEffect.deps 中，这样就完成了 activeEffect 和 deps 的双向关联</span></span><br><span class="line">    activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(deps);</span><br><span class="line">	  <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增</span></span><br><span class="line">    <span class="comment">// 复制一份 effects，避免遍历时 effects 被增删而导致死循环</span></span><br><span class="line">    <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>(effects);</span><br><span class="line">    <span class="comment">// 执行副作用函数</span></span><br><span class="line">    effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>());</span><br><span class="line">	  <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-5-嵌套的-effect-与-effect-栈"><a href="#4-5-嵌套的-effect-与-effect-栈" class="headerlink" title="4.5 嵌套的 effect 与 effect 栈"></a>4.5 嵌套的 effect 与 effect 栈</h5><h6 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h6><p>支持 effect 嵌套。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">bar</span>: <span class="literal">true</span>, <span class="attr">foo</span>: <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;<span class="comment">/* ... */</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp1, temp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effectFn1 嵌套了 effectFn2</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effectFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effectFn1 执行&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effectFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effectFn2 执行&#x27;</span>);</span><br><span class="line">        temp2 = obj.<span class="property">bar</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    temp1 = obj.<span class="property">foo</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h6 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h6><p>依赖关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line"> |--&gt; bar</span><br><span class="line">       |--&gt; effectFn2</span><br><span class="line"> |--&gt; foo</span><br><span class="line">       |--&gt; effectFn1</span><br></pre></td></tr></table></figure>

<p>期待输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">effectFn1 执行</span><br><span class="line">effectFn2 执行</span><br><span class="line">effectFn1 执行</span><br><span class="line">effectFn2 执行</span><br></pre></td></tr></table></figure>

<p>实际输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">effectFn1 执行</span><br><span class="line">effectFn2 执行</span><br><span class="line">effectFn2 执行</span><br></pre></td></tr></table></figure>

<p>原因分析</p>
<p><code>effectFn2</code> 执行完后 <code>activeEffect</code> 依然指向 <code>effectFn2</code> 。</p>
<h6 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h6><p>创建一个副作用函数栈 <code>effectStack</code> ，在副作用执行时，将当前副作用函数压栈，待副作用函数执行完毕后将其出栈，并始终让 <code>activeEffect</code> 指向栈顶元素。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/7af26a27b7ee8342476876cb423eaf447621715c">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"><span class="comment">// effect 栈</span></span><br><span class="line"><span class="keyword">const</span> effectStack = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">cleanup</span>(effectFn);</span><br><span class="line">        activeEffect = effectFn;</span><br><span class="line">	      <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增</span></span><br><span class="line">        <span class="comment">// 在调用前压栈</span></span><br><span class="line">        effectStack.<span class="title function_">push</span>(effectFn);</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">        <span class="comment">// 调用完毕后出栈</span></span><br><span class="line">        effectStack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="comment">// 并更新 activeEffect 指向栈顶的副作用函数</span></span><br><span class="line">        activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">	      <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    effectFn.<span class="property">deps</span> = [];</span><br><span class="line">    <span class="title function_">effectFn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-6-避免无限递归循环"><a href="#4-6-避免无限递归循环" class="headerlink" title="4.6 避免无限递归循环"></a>4.6 避免无限递归循环</h5><h6 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;<span class="comment">/* ... */</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> obj.<span class="property">foo</span>++)</span><br></pre></td></tr></table></figure>

<p>上述代码执行会引起栈溢出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">RangeError</span>: <span class="title class_">Maximum</span> call stack size exceed</span><br></pre></td></tr></table></figure>

<h6 id="分析问题-1"><a href="#分析问题-1" class="headerlink" title="分析问题"></a>分析问题</h6><p><code>obj.foo = obj.foo + 1</code> 既会读取，也会设置 <code>obj.foo</code> 。因此执行流程会变成 <code>track</code> &#x3D;&gt; <code>trigger</code>  &#x3D;&gt; <code>trigger</code> &#x3D;&gt; … 无限递归的调用 <code>trigger</code> 函数。</p>
<h6 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h6><p>如果 <code>trigger</code> 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/6c3ae2b3d79d88424429d1e4104389ef83a45d6a">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  	<span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt; 新增</span></span><br><span class="line">    effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。</span></span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect) &#123;</span><br><span class="line">            effectsToRun.<span class="title function_">add</span>(effect)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">	  <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">    <span class="comment">// 执行副作用函数</span></span><br><span class="line">    effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-7-调度执行"><a href="#4-7-调度执行" class="headerlink" title="4.7 调度执行"></a>4.7 调度执行</h5><h6 id="新需求-1"><a href="#新需求-1" class="headerlink" title="新需求"></a>新需求</h6><p>可调度。当 <code>trigger</code> 动作触发副作用函数执行时，有能力决定副作用函数执行的时机、次数以及方式。</p>
<h6 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;<span class="comment">/* ... */</span>&#125;)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>))</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;over&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当前结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">over</span><br></pre></td></tr></table></figure>

<p>期待结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">over</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h6 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h6><p>为 <code>effect</code> 函数设计一个选项参数 <code>options</code> ，允许用户指定调度器。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/c4d138b0f98b0ce524c01f2f08351b4629619471">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将 options 挂载到 effectFn 上</span></span><br><span class="line">    effectFn.<span class="property">options</span> = options;</span><br><span class="line">    effectFn.<span class="property">deps</span> = [];</span><br><span class="line">    <span class="title function_">effectFn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">		<span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行副作用函数</span></span><br><span class="line">    effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果一个副作用函数存在调度器，则调用调度器，并将其作为参数传入</span></span><br><span class="line">        <span class="keyword">if</span> (effect.<span class="property">options</span> &amp;&amp; effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">            effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">effect</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样使用</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="title function_">scheduler</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.<span class="property">foo</span>++;</span><br></pre></td></tr></table></figure>

<h6 id="引申-实现简易调度器合并多次重复更新"><a href="#引申-实现简易调度器合并多次重复更新" class="headerlink" title="引申: 实现简易调度器合并多次重复更新"></a>引申: 实现简易调度器合并多次重复更新</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个任务队列</span></span><br><span class="line"><span class="keyword">const</span> jobQueue = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="comment">// 创建一个 promise 实例，利用它将 任务队列的执行 添加到微任务队列</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表是否正在刷新队列的标志，避免任务队列重复执行</span></span><br><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 任务队列刷新时无需再刷新</span></span><br><span class="line">  <span class="keyword">if</span> (isFlushing) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 设置为 true，代表正在刷新</span></span><br><span class="line">  isFlushing = <span class="literal">true</span>;</span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    jobQueue.<span class="title function_">forEach</span>(<span class="function">(<span class="params">job</span>) =&gt;</span> <span class="title function_">job</span>());</span><br><span class="line">  &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 结束后重置 isFlushing</span></span><br><span class="line">    isFlushing = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">effect</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="title function_">scheduler</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">      <span class="comment">// 每次调度时将副作用函数添加到 jobQueue 队列中</span></span><br><span class="line">      jobQueue.<span class="title function_">add</span>(fn);</span><br><span class="line">      <span class="comment">// 调用 flushingJob 刷新队列</span></span><br><span class="line">      <span class="title function_">flushJob</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">obj.<span class="property">foo</span>++;</span><br><span class="line">obj.<span class="property">foo</span>++;</span><br></pre></td></tr></table></figure>



<h5 id="4-8-计算属性-computed-与-lazy"><a href="#4-8-计算属性-computed-与-lazy" class="headerlink" title="4.8 计算属性 computed 与 lazy"></a>4.8 计算属性 computed 与 lazy</h5><h6 id="新需求-2"><a href="#新需求-2" class="headerlink" title="新需求"></a>新需求</h6><ol>
<li>懒执行的 <code>effect</code> 。</li>
<li>计算属性 <code>computed</code>（lazy &amp; cacheable）。</li>
</ol>
<h6 id="需求分析-2"><a href="#需求分析-2" class="headerlink" title="需求分析"></a>需求分析</h6><ol>
<li>当前 <code>effect</code> 函数会立即执行传递给它的副作用函数，有些场景下不希望它立即执行，例如计算属性。</li>
<li>在需求 1 的基础上实现。</li>
</ol>
<h6 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h6><ol>
<li><p>通过给 <code>effect</code> 函数传递的 <code>options</code> 中添加 <code>lazy</code> 属性。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/5de5cb47f03018ca9e50b3a2fc568f01d7b40029">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有非 lazy 时才执行</span></span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行副作用函数</span></span><br><span class="line">        <span class="title function_">effectFn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将副作用函数作为返回值返回，在懒执行时可以交由用户决定执行时机</span></span><br><span class="line">    <span class="keyword">return</span> effectFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="title function_">effectFn</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>把一个对象某个属性的 <code>getter</code> （<code>computed</code> 的功能也只需要 <code>getter</code> ）传递给 <code>effect</code> ，在触发 <code>getter</code> 的时候执行副作用函数。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/d66688898095ef6a5643425fda4ab6ed6ed8b3e2">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v0.1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">    <span class="comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span></span><br><span class="line">    <span class="comment">// 此时 effectFn 的返回值就是 getter 的返回值</span></span><br><span class="line">    <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">		<span class="comment">// 创建一个临时对象，用来当作载体</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">effectFn</span>();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;<span class="comment">/* ... */</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumRes = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> obj.<span class="property">bar</span> + obj.<span class="property">foo</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>); <span class="comment">// 3</span></span><br><span class="line">obj.<span class="property">bar</span>++;</span><br><span class="line">obj.<span class="property">foo</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>); <span class="comment">// 5，又计算了一次</span></span><br></pre></td></tr></table></figure>

<p>但是 v0.1 版本不支持缓存。创建一个变量缓存计算值，另创建一个标识 <code>dirty</code> 判断是否需要更新缓存，并在依赖修改的时候将 <code>dirty</code> 设置为 <code>true</code> 。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/21ed09c6145e4c9cda47f2ff4f053238cd1fbb93">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v0.2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 当调度器被执行时，说明依赖项被更新了，即 computed 的缓存失效了，需要重新计算</span></span><br><span class="line">            dirty = <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  	<span class="comment">// 用于缓存上一次计算的值</span></span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="comment">// 用来标识是否需要重新计算值，true 表示需要重新计算</span></span><br><span class="line">    <span class="keyword">let</span> dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">                <span class="comment">// 重新计算，并更新缓存</span></span><br><span class="line">                value = <span class="title function_">effectFn</span>();</span><br><span class="line">                <span class="comment">// 将 dirty 设置为 false，在 dirty 被重新设置为 true 之前，缓存值 value 一直有效</span></span><br><span class="line">                dirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;<span class="comment">/* ... */</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> sumRes = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> obj.<span class="property">bar</span> + obj.<span class="property">foo</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>); <span class="comment">// 3</span></span><br><span class="line">obj.<span class="property">bar</span>++;</span><br><span class="line">obj.<span class="property">foo</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>); <span class="comment">// 5，不会重新计算</span></span><br></pre></td></tr></table></figure>

<p>然而，v0.2 版本还存在问题，在另外的 <code>effect</code> 中访问计算属性的值时，当值修改了，该 <code>effect</code> 不会自动执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumRes = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> obj.<span class="property">bar</span> + obj.<span class="property">foo</span>)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在该副作用函数中读取 sumRes.value</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 修改 obj.foo 导致 sumRes.value 修改，但是上面的 effect 没有再次执行</span></span><br><span class="line">obj.<span class="property">foo</span>++</span><br></pre></td></tr></table></figure>

<p>究其原因，本质上是发生了 <code>effect</code> 嵌套，响应式数据没有将外层的  <code>effect</code> 收集到依赖中。解决办法是当读取计算属性时，手动调用 <code>track</code> 函数进行追踪，当计算属性依赖的响应式数据变化时，手动调用 <code>trigger</code> 触发响应。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/bf9bfda1f5e7ce51d0ed96f41e9ba6439d57c9d3">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1.0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">                <span class="comment">// 当调度器被执行时，说明依赖项被更新了，即 computed 的缓存失效了，需要重新计算</span></span><br><span class="line">                dirty = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 当计算属性依赖的响应式数据更新时手动调用 trigger 触发响应</span></span><br><span class="line">                <span class="title function_">trigger</span>(obj, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    <span class="keyword">let</span> dirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">                value = <span class="title function_">effectFn</span>();</span><br><span class="line">                dirty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当读取时手动调用 track 追踪变化</span></span><br><span class="line">            <span class="title function_">track</span>(obj, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;<span class="comment">/* ... */</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> sumRes = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> obj.<span class="property">bar</span> + obj.<span class="property">foo</span>)</span><br><span class="line"><span class="title function_">effect</span>(<span class="title function_">effectFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sumRes.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它们建立了这样的联系</span></span><br><span class="line">bucket</span><br><span class="line">	|--&gt; data</span><br><span class="line">				|--&gt; <span class="function">() =&gt;</span> obj.<span class="property">bar</span> + obj.<span class="property">foo</span></span><br><span class="line">  |--&gt; <span class="title function_">computed</span>(<span class="function">() =&gt;</span> obj.<span class="property">bar</span> + obj.<span class="property">foo</span>)</span><br><span class="line">			  |--&gt; effectFn</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="4-9-watch-的实现原理"><a href="#4-9-watch-的实现原理" class="headerlink" title="4.9 watch 的实现原理"></a>4.9 watch 的实现原理</h5><h6 id="新需求-3"><a href="#新需求-3" class="headerlink" title="新需求"></a>新需求</h6><p>支持 <code>watch</code></p>
<h6 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h6><p>利用 <code>effect</code> 和 <code>options.scheduler</code> 。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/dae666b5f4db0ad813173c4467802753b7eba26a">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb</span>) &#123;</span><br><span class="line">    <span class="comment">// getter 用来读取原对象，以收集依赖</span></span><br><span class="line">    <span class="keyword">let</span> getter;</span><br><span class="line">    <span class="comment">// 支持传入一个 getter 进来</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        getter = source;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldVal, newVal;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> 当监听整个响应式对象时，oldVal 和 newVal 总是一样的</span></span><br><span class="line">    <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="title function_">getter</span>(), &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 在调度器中重新执行副作用函数，得到最新值</span></span><br><span class="line">            newVal = <span class="title function_">effectFn</span>();</span><br><span class="line">            <span class="title function_">cb</span>(newVal, oldVal);</span><br><span class="line">            <span class="comment">// 此次的新值就是下次更新的旧值，用此次的新值替换旧值</span></span><br><span class="line">            oldVal = newVal;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 先手动调用副作用函数，作为第一个旧值</span></span><br><span class="line">    oldVal = <span class="title function_">effectFn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value, seen = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 value 是原始值或者已经被读取过，则什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;object&quot;</span> || value === <span class="literal">null</span> || seen.<span class="title function_">has</span>(value))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 value 放入 seen 集合中，表示已经遍历过，避免循环引用造成死循环</span></span><br><span class="line">    seen.<span class="title function_">add</span>(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环递归读取 value 的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-10-立即执行的-watch-与回调执行时机"><a href="#4-10-立即执行的-watch-与回调执行时机" class="headerlink" title="4.10 立即执行的 watch 与回调执行时机"></a>4.10 立即执行的 watch 与回调执行时机</h5><h6 id="新需求-4"><a href="#新需求-4" class="headerlink" title="新需求"></a>新需求</h6><p>支持立即执行和控制回调执行的时机</p>
<h6 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h6><p>增加 <code>options</code> 入参，通过 <code>options.immediate</code> 来控制是否立即执行，通过 <code>options.flush</code> 控制执行时机。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/d1fd6d99023bebe4a2b9cf93a1277d6c89c80bb9">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options = &#123; immediate: <span class="literal">false</span>, flush: <span class="string">&quot;sync&quot;</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getter;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        getter = source;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> oldVal, newVal;</span><br><span class="line">  	<span class="comment">// &gt;&gt;&gt;&gt; 修改</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在调度器中重新执行副作用函数，得到最新值</span></span><br><span class="line">        newVal = <span class="title function_">effectFn</span>();</span><br><span class="line">        <span class="title function_">cb</span>(newVal, oldVal);</span><br><span class="line">        <span class="comment">// 此次的新值就是下次更新的旧值，用此次的新值替换旧值</span></span><br><span class="line">        oldVal = newVal;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="title function_">getter</span>(), &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.<span class="property">flush</span> === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(job);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">job</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 options.immediate 为 true 时，立即执行调度器</span></span><br><span class="line">        <span class="title function_">job</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldVal = <span class="title function_">effectFn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// &gt;&gt;&gt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-11-过期的副作用"><a href="#4-11-过期的副作用" class="headerlink" title="4.11 过期的副作用"></a>4.11 过期的副作用</h5><h6 id="新需求-5"><a href="#新需求-5" class="headerlink" title="新需求"></a>新需求</h6><p>解决竞态问题。</p>
<blockquote>
<p>竞态问题：多个同样的请求发送后，过期的请求（较早发送的请求）依然修改了数据，导致数据时效性问题。</p>
</blockquote>
<h6 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h6><p>在 <code>watch</code> 的第二个参数，即回调函数中，多传递一个用于通知本次副作用过期的函数。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/e0d709217199c828bd892fe2218126e462fa7f46">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options = &#123; immediate: <span class="literal">false</span>, flush: <span class="string">&quot;sync&quot;</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getter;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        getter = source;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> oldVal, newVal;</span><br><span class="line">  	<span class="comment">// &gt;&gt;&gt;&gt; 修改</span></span><br><span class="line">    <span class="comment">// 用于保存用户注册的过期回调</span></span><br><span class="line">    <span class="keyword">let</span> cleanup;</span><br><span class="line">    <span class="comment">// 定义 onInvalidate 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onInvalidate</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="comment">// 将过期回调保存到 cleanup 中</span></span><br><span class="line">        cleanup = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        newVal = <span class="title function_">effectFn</span>();</span><br><span class="line">        <span class="comment">// 每次调度器执行，说明之前的任务已经过期了</span></span><br><span class="line">        <span class="comment">// 在回调执行前，先调用过期回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> cleanup === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_">cleanup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 onInvalidate 作为第三个参数，以便用户使用</span></span><br><span class="line">        <span class="title function_">cb</span>(newVal, oldVal, onInvalidate);</span><br><span class="line">        oldVal = newVal;</span><br><span class="line">    &#125;;</span><br><span class="line">  	<span class="comment">// &gt;&gt;&gt;&gt;</span></span><br><span class="line">    <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="title function_">getter</span>(), &#123;</span><br><span class="line">        <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.<span class="property">flush</span> === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(job);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">job</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">        <span class="title function_">job</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldVal = <span class="title function_">effectFn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-12-总结"><a href="#4-12-总结" class="headerlink" title="4.12 总结"></a>4.12 总结</h5><h6 id="1-为什么使用-WeakMap-存储副作用？"><a href="#1-为什么使用-WeakMap-存储副作用？" class="headerlink" title="1. 为什么使用 WeakMap 存储副作用？"></a>1. 为什么使用 WeakMap 存储副作用？</h6><p>WeakMap 对 key 是弱引用，不影响 GC，一旦 key 被 GC 回收，那么对应的键和值就访问不到了。因此 WeakMap 常用来存储那些只有当 key 被引用的对象存在时（没被回收）才有价值的信息。如果 target 对象没有任何引用了，说明用户侧不再需要它了，这时 GC 就会完成回收任务。</p>
<h6 id="2-为什么-trigger-中依赖集合要复制后再进行遍历？"><a href="#2-为什么-trigger-中依赖集合要复制后再进行遍历？" class="headerlink" title="2. 为什么 trigger 中依赖集合要复制后再进行遍历？"></a>2. 为什么 trigger 中依赖集合要复制后再进行遍历？</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// &gt;&gt;&gt;&gt; 复制依赖集合</span></span><br><span class="line">    <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>(effects);</span><br><span class="line">    effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为依赖集合 <code>effects</code> 在遍历中会执行 <code>effect</code> 副作用函数，而 <code>effect</code> 每次调用前，会清除依赖集合 <code>effects</code> 对自身的关联，也就是<strong>从 <code>effects</code> 中将自身删除</strong>，但是副作用函数调用时，会触发 <code>track</code> 函数，导致自身<strong>又被重新加入到 <code>effects</code> 中</strong>，而此时 <code>effects</code> 的遍历仍在进行，根据 ECMA 的规范，在调用 <code>forEach</code> 遍历 <code>Set</code> 集合时，如果一个值已经被访问过，但该值被删除并重新添加到集合，如果此时 <code>forEach</code> 仍未结束，那么该值会被重新访问。因此，如果不重新复制的话，会<strong>导致遍历进入无限循环</strong>。</p>
<h3 id="第五章-非原始值的响应式方案"><a href="#第五章-非原始值的响应式方案" class="headerlink" title="第五章 非原始值的响应式方案"></a>第五章 非原始值的响应式方案</h3><h5 id="5-1-理解-Proxy-和-Reflect"><a href="#5-1-理解-Proxy-和-Reflect" class="headerlink" title="5.1 理解 Proxy 和 Reflect"></a>5.1 理解 Proxy 和 Reflect</h5><p>任何在 <code>Proxy</code> 的拦截器中能够找到的方法，都能够在 <code>Reflect</code> 中找到同名函数。</p>
<h6 id="存在的问题-2"><a href="#存在的问题-2" class="headerlink" title="存在的问题"></a>存在的问题</h6><p>考虑之前的响应式实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123;</span><br><span class="line">    <span class="comment">// 这里的 this 指向谁?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, key);</span><br><span class="line">    <span class="comment">// 注意，这里没有用 Reflect.get 完成读取</span></span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  p.<span class="property">bar</span>;</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="property">foo</span>++;</span><br></pre></td></tr></table></figure>

<h6 id="分析问题-2"><a href="#分析问题-2" class="headerlink" title="分析问题"></a>分析问题</h6><p>实际上，在 <code>obj.bar</code> 的 <code>getter</code> 中， <code>this</code> 指向的是原始对象 <code>obj</code> ，这样就绕过了代理对象，就无法建立响应联系。</p>
<h6 id="解决方案-9"><a href="#解决方案-9" class="headerlink" title="解决方案"></a>解决方案</h6><p>通过 <code>Reflect.get</code> 去修正 <code>getter</code> 中的 <code>this</code> 指向。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/9a74d4050b1ba351952c7df37864cfd8a04b54f4">修改记录</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, key);</span><br><span class="line">    <span class="comment">// 使用 Reflect.get 完成读取</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代理对象的 <code>get</code> 拦截函数接收的第三个参数 <code>receiver</code> ，代表谁在读取属性。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="property">bar</span> <span class="comment">// 代理对象 p 在读取 bar 属性</span></span><br></pre></td></tr></table></figure>

<p>此时，<code>receiver</code> 就是 <code>p</code> 。</p>
<p>使用 <code>Reflect.get(target, key, receiver)</code> 去访问 <code>bar</code> 属性时，它的 <code>getter</code> 函数中的 <code>this</code> 就会指向代理对象 <code>p</code> 了。</p>
<h5 id="5-2-JavaScript-对象及-Proxy-的工作原理"><a href="#5-2-JavaScript-对象及-Proxy-的工作原理" class="headerlink" title="5.2 JavaScript 对象及 Proxy 的工作原理"></a>5.2 JavaScript 对象及 Proxy 的工作原理</h5><h6 id="常规对象-ordinary-object"><a href="#常规对象-ordinary-object" class="headerlink" title="常规对象(ordinary object)"></a>常规对象(ordinary object)</h6><ul>
<li>对于所必须部署的 11 个必要的内部方法（<code>[[Get]]</code> 、<code>[[Set]]</code> 等），必须使用 ECMA 规范 10.1.x 节给出的定义实现。</li>
<li>对于内部方法 <code>[[Call]]</code> ，必须使用 ECMA 规范 10.2.1 节给出的定义实现。</li>
<li>对于内部方法 <code>[[Constructor]]</code> ，必须使用 ECMA 规范 10.2.2 节给出的定义实现。</li>
</ul>
<h6 id="异质对象-exotic-object"><a href="#异质对象-exotic-object" class="headerlink" title="异质对象(exotic object)"></a>异质对象(exotic object)</h6><p>任何不属于常规对象的对象都是异质对象。</p>
<h6 id="内部方法-internal-method"><a href="#内部方法-internal-method" class="headerlink" title="内部方法(internal method)"></a>内部方法(internal method)</h6><p>当我们对一个对象进行操作时<strong>在引擎内部调用的方法</strong>。内部方法对于 JavaScript 使用者是不可见的。</p>
<p>例如我们访问对象属性时，引擎内部会调用 <code>[[Get]]</code> 这个内部方法来读取属性值。</p>
<blockquote>
<p>在 ECMAScript 规范中使用 [[xxx]] 来代表内部方法或内部槽。</p>
</blockquote>
<h6 id="如何区分一个对象是普通对象还是函数？"><a href="#如何区分一个对象是普通对象还是函数？" class="headerlink" title="如何区分一个对象是普通对象还是函数？"></a>如何区分一个对象是普通对象还是函数？</h6><p>通过内部方法和内部槽来区分对象，例如函数对象会部署内部方法 <code>[[Call]]</code> ，而普通对象则不会。</p>
<h5 id="5-3-如何代理-Object"><a href="#5-3-如何代理-Object" class="headerlink" title="5.3 如何代理 Object"></a>5.3 如何代理 Object</h5><p><em><strong>从本节开始实现响应式数据。</strong></em></p>
<p>本节<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/c133792c9b0ac35a9a9db7527a0382a1583ef046">修改记录</a> 。</p>
<p>响应系统应该拦截一切读取操作，以便当数据变化时能够正确地触发响应。读取操作和对应的 trap 方案如下：</p>
<ul>
<li><p>访问属性： <code>obj.foo</code></p>
<p>使用 <code>get</code> 拦截。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">	<span class="title function_">track</span>(target, key)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断对象或原型上是否存在给定的 key： <code>key in obj</code> </p>
<p>使用 <code>has</code> 拦截。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">has</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">	<span class="title function_">track</span>(target, key)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>for...in</code> 循环遍历对象： <code>for (const key in obj)</code> </p>
<p>使用 <code>ownKeys</code> 拦截，并用唯一的 <code>ITERATE_KEY</code> 作为追踪的 <code>key</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ITERATE_KEY</span> = <span class="title class_">Symbol</span>() <span class="comment">// 创建一个唯一的 key 来关联遍历相关的副作用</span></span><br><span class="line"><span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">	<span class="title function_">track</span>(target, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为对象<strong>添加新的属性</strong>时，也应该触发与 <code>ITERATE_KEY</code> 相关联的副作用。所以需要优化 <code>trigger</code> 函数 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;&gt; 新增</span></span><br><span class="line">  <span class="comment">// 获取与 ITERATE_KEY 相关联的副作用函数</span></span><br><span class="line">  <span class="keyword">const</span> iterateEffects = depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun</span></span><br><span class="line">  iterateEffects &amp;&amp;</span><br><span class="line">      iterateEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (effect !== activeEffect) &#123;</span><br><span class="line">              effectsToRun.<span class="title function_">add</span>(effect);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;&gt;</span></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effect.<span class="property">options</span> &amp;&amp; effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">          effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">effect</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是此时修改已存在属性的值时也会触发 <code>ITERATE_KEY</code> 关联的副作用函数，这并不是期望的，所以 <code>trigger</code> 需要知道此次操作是新增还是修改。</p>
<p>在 <code>set</code> 拦截函数中区分属性的操作行为，并传递给 <code>effect</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义触发类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TriggerType</span> = &#123;</span><br><span class="line">    <span class="attr">SET</span>: <span class="string">&#x27;SET&#x27;</span>,</span><br><span class="line">    <span class="attr">ADD</span>: <span class="string">&#x27;ADD&#x27;</span>,</span><br><span class="line">    <span class="attr">DELETE</span>: <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果属性不存在，说明是添加新属性，否则是设置已有属性</span></span><br><span class="line">    <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key) ? <span class="title class_">TriggerType</span>.<span class="property">SET</span> : <span class="title class_">TriggerType</span>.<span class="property">ADD</span>;</span><br><span class="line">    <span class="comment">// 设置属性值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newVal, receiver);</span><br><span class="line">    <span class="comment">// 执行依赖的副作用函数，并将 type 作为第三个参数传递</span></span><br><span class="line">    <span class="title function_">trigger</span>(target, key, type);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同样地，<strong>删除属性</strong>也应该触发 <code>ITERATE_KEY</code> 关联的副作用函数。</p>
<p>创建 <code>deleteProperty</code> 拦截函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 拦截 delete 操作</span></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查被操作的属性是否是对象自己的属性</span></span><br><span class="line">    <span class="keyword">const</span> hadKey = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key);</span><br><span class="line">    <span class="comment">// 进行属性删除</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; hadKey) &#123;</span><br><span class="line">        <span class="comment">// 只有当被删除属性是对象自己的属性且删除成功删除时，才触发更新</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, key, <span class="title class_">TriggerType</span>.<span class="property">DELETE</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使 <code>effect</code> 响应属性新增和删除行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;&gt; 修改</span></span><br><span class="line">  <span class="comment">// 只有当操作类型 type 为 ADD 或 DELETE 时，才触发</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="title class_">TriggerType</span>.<span class="property">ADD</span> || type === <span class="title class_">TriggerType</span>.<span class="property">DELETE</span>) &#123;</span><br><span class="line">      <span class="comment">// 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun</span></span><br><span class="line">      iterateEffects &amp;&amp;</span><br><span class="line">        iterateEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。</span></span><br><span class="line">          <span class="keyword">if</span> (effect !== activeEffect) &#123;</span><br><span class="line">              effectsToRun.<span class="title function_">add</span>(effect);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;&gt;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-4-合理地触发响应"><a href="#5-4-合理地触发响应" class="headerlink" title="5.4 合理地触发响应"></a>5.4 合理地触发响应</h5><h6 id="存在的问题-3"><a href="#存在的问题-3" class="headerlink" title="存在的问题"></a>存在的问题</h6><ol>
<li><p>当值没有变化时，不应该触发响应。</p>
</li>
<li><p>考虑如下使用场景，副作用会执行两次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proto = &#123; <span class="attr">bar</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="title function_">reactive</span>(obj);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="title function_">reactive</span>(proto);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(child, parent);</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">bar</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.<span class="property">bar</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="分析问题-3"><a href="#分析问题-3" class="headerlink" title="分析问题"></a>分析问题</h6><ol start="2">
<li>由于 <code>bar</code> 属性是存在 <code>child</code> 对象的原型 <code>parent</code> 对象中，所以 <code>child.bar</code> 会同时触发 <code>child</code> 和 <code>parent</code> 的 <code>get</code> 拦截函数，所以该副作用函数会同时被 <code>child.bar</code> 和 <code>parent.bar</code> 收集。当使用 <code>child.bar</code> 赋值的时候，</li>
</ol>
<h6 id="解决方案-10"><a href="#解决方案-10" class="headerlink" title="解决方案"></a>解决方案</h6><ol>
<li><p>在触发响应之前判断新值和旧值是否相等。<a target="_blank" rel="noopener" href="https://gitee.com/jokerwon/my-vue/commit/89d9287d2b410b3d32604dd0d20e69797e64ea6c">修改记录</a> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">target, key, newVal, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldVal = target[key];</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key) ? <span class="title class_">TriggerType</span>.<span class="property">SET</span> : <span class="title class_">TriggerType</span>.<span class="property">ADD</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newVal, receiver);</span><br><span class="line">  <span class="comment">// 只有当新值和旧值不全等且都不是 NaN 时才触发响应</span></span><br><span class="line">  <span class="keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123;</span><br><span class="line">      <span class="comment">// 执行依赖的副作用函数，并将 type 作为第三个参数传递</span></span><br><span class="line">      <span class="title function_">trigger</span>(target, key, type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

                </section>

                
                

                

            </article>

            
            <nav class="dis_flex al_post_nav">
                <a class="al_post_nav_item dis_flex_acenter" href="/2022/06/12/MonoRepo/">
                    
                        <svg class="al_arrow">
                            <use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-arrow-left"></use>
                        </svg>
                        <span class="al_text_ellipsis al_post_nav_desc">MonoRepo</span>
                    
                </a>
                <a class="al_post_nav_item dis_flex_acenter" href="/2022/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                    
                        <span class="al_text_ellipsis al_post_nav_desc">设计模式</span>
                        <svg class="al_arrow">
                            <use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-arrow-right"></use>
                        </svg>
                    
                </a>
            </nav>
        </div>
    </div>


        <div class="al_index_footer dis_flex_center">
    <div class="al_index_footer_item al_index_footer_title">
        Joker Won
    </div>

    
    

    <div class="al_index_footer_item al_index_footer_extra">
        Created By 
        <a target="_blank" rel="noopener" href="https://github.com/iGuan7u/Acetolog">AcetoLog</a>
         · Power By 
        <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
    </div>

    <div class="al_index_footer_item al_index_footer_extra_right">
        All Right Reserved
    </div>
</div>

        <script type="text/javascript" async="async" src="/javascripts/acelog.js"></script>
        
        
        
        
        

    </body>
</html>